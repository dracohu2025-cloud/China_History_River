# Client Integration Guide

This guide describes how to build a "Thick Client" application that consumes podcast data generated by the `epub-to-pod` backend. The client will interact directly with Supabase to fetch job status, audio, images, and scripts.

## Prerequisites

Ensure your client application has the following configuration:

1.  **Supabase URL**: `https://zhvczrrcwpxgrifshhmh.supabase.co`
2.  **Supabase Anon Key**: (Provided separately)

## Data Schema

The core data resides in the `jobs` table in Supabase.

### `jobs` Table

| Column | Type | Description |
| :--- | :--- | :--- |
| `id` | UUID | Unique Job ID. |
| `status` | Text | `queued`, `processing`, `completed`, or `failed`. |
| `progress` | Integer | 0-100 percentage. |
| `current_step` | Text | Current processing step (e.g., `scripting`, `merging`). |
| `output_data` | JSONB | Contains the final podcast assets (script, audio, images). |
| `error_message` | Text | Error details if failed. |
| `created_at` | Timestamp | Creation time. |

### `output_data` Structure

When a job is `completed`, the `output_data` column will contain a JSON object with the following structure:

```typescript
interface JobOutput {
  script: ScriptSegment[];
  audioUrl: string; // Public URL of the final MP3
  audioPath: string; // Storage path (e.g., "userId/jobId/podcast.mp3")
}

interface ScriptSegment {
  speaker: 'Male' | 'Female';
  text: string;
  visualPrompt: string;
  generatedImageUrl?: string; // Public URL of the segment's image
}
```

## Fetching Data

### 1. Fetch Completed Jobs

To list all completed podcasts for a user, query the `jobs` table filtering by `status = 'completed'`.

```javascript
import { createClient } from '@supabase/supabase-js';

const supabase = createClient('YOUR_SUPABASE_URL', 'YOUR_ANON_KEY');

async function fetchPodcasts(userId) {
  const { data, error } = await supabase
    .from('jobs')
    .select('*')
    .eq('user_id', userId) // Assuming you have user_id in jobs table
    .eq('status', 'completed')
    .order('created_at', { ascending: false });

  if (error) console.error('Error fetching podcasts:', error);
  return data;
}
```

### 2. Fetch a Single Job

To get details for a specific podcast (e.g., for the player view):

```javascript
async function getPodcast(jobId) {
  const { data, error } = await supabase
    .from('jobs')
    .select('*')
    .eq('id', jobId)
    .single();

  return data;
}
```

## Playing the Podcast

The player logic should use the data from `output_data`:

1.  **Audio**: Use `output_data.audioUrl` as the source for your `<audio>` element.
2.  **Images**: The `output_data.script` array contains the sequence of segments.
    *   Each segment has a `generatedImageUrl`.
    *   **Synchronization**: Since the current backend merges audio into a single file without per-segment timestamps, you have two options:
        *   **Simple Slideshow**: Change images at fixed intervals (e.g., total duration / segment count).
        *   **Text Sync**: If you implement a transcription alignment service later, you can map segments to time.
        *   **Current Best Practice**: Display the image corresponding to the current segment being read. *Note: Without precise timestamps from the backend, you might need to estimate or just show a gallery.*

## Asset URLs

All assets are stored in the `podcasts` bucket and are publicly accessible.

*   **Audio**: `https://[PROJECT_REF].supabase.co/storage/v1/object/public/podcasts/[USER_ID]/[JOB_ID]/podcast.mp3`
*   **Images**: `https://[PROJECT_REF].supabase.co/storage/v1/object/public/podcasts/[USER_ID]/[JOB_ID]/images/[INDEX].png`

The `output_data` JSON already provides these full public URLs for convenience.
